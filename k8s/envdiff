#!/usr/bin/env python

import yaml, sys, os, os.path, string, subprocess, optparse, re

failed = False

ALLOWED_DIFFERENCES={
  ".spec.replicas",
  ".spec.template.spec.containers[0].args.log.level",
  ".spec.template.spec.containers[0].args.app.collector",
  ".spec.template.spec.containers[0].args.app.collector.s3",
  ".spec.template.spec.containers[0].args.app.control.router",
  ".spec.template.spec.containers[0].args.database-uri",
  ".spec.template.spec.containers[0].args.endpoint",
  ".spec.template.spec.containers[0].args.domain",
  ".spec.template.spec.containers[0].args.session-secret",
  ".spec.template.spec.containers[0].args.github-client-id",
  ".spec.template.spec.containers[0].args.github-client-secret",
  ".spec.template.spec.containers[0].args.github-redirect-url",
  ".spec.template.spec.containers[0].args.google-client-id",
  ".spec.template.spec.containers[0].args.google-redirect-url",
  ".spec.template.spec.containers[0].args.google-client-secret",
}

ALLOWED_MISSING={
  "imagePullPolicy"
}

# Differences in the following fields will be ignore if run
# with --noversions.
VERSION_FIELDS={
  ".spec.template.spec.containers[0].image",
  ".spec.template.spec.containers[1].image",
  ".spec.template.spec.containers[2].image",
  ".spec.template.spec.containers[3].image",
  ".spec.template.spec.containers[4].image",
  ".metadata.name"
}

def parse_args(args):
  parsed = {}
  while len(args):
    arg = args.pop(0)
    m = re.match(r"^\-(?:\-)?(?P<name>[a-zA-Z0-9.\-_]+)(?:=| )?(?P<value>.+)?$", arg)
    if m is not None:
      parsed[m.group("name")] = m.group("value")
    else:
      break
  return parsed, args

def diff_args(path, want, have):
  # args are a list, but we're going to parse as a map
  want, _ = parse_args(want)
  have, _ = parse_args(have)
  for d in diff_dicts(path, want, have):
    yield d

def diff_lists(path, want, have):
  if len(want) != len(have):
    yield "len(%s): %d != %d" % (path, len(want), len(have))

  for i, (want_v, have_v) in enumerate(zip(want, have)):
     for d in diff("%s[%d]" % (path, i), want_v, have_v):
       yield d

def diff_dicts(path, want, have):
  for k, want_v in want.iteritems():
    key_path = "%s.%s" % (path, k)

    if k in have:
      if k == "args":
        for d in diff_args(key_path, want_v, have[k]):
          yield d
      else:
        for d in diff(key_path, want_v, have[k]):
          yield d

    elif k not in ALLOWED_MISSING:
      yield  "%s: '%s' missing" % (path, k)

def diff(path, want, have):
  if isinstance(want, dict):
    for d in diff_dicts(path, want, have):
      yield d

  elif isinstance(want, list):
    for d in diff_lists(path, want, have):
      yield d

  elif not options.versions and path in VERSION_FIELDS:
    pass

  elif path in ALLOWED_DIFFERENCES:
    pass

  else:
    if want != have:
      yield "%s: '%s' != '%s'" % (path, want, have)

def check_file(orig, last):
  _, extension = os.path.splitext(orig)
  if extension != ".yaml":
    return

  with open(orig, 'r') as stream:
    orig_yaml = yaml.load(stream)

  try:
    with open(last, 'r') as stream:
      last_yaml = yaml.load(stream)
  except IOError:
    check(False, "'%s' missing", last)
    return

  diffs = list(diff("", orig_yaml, last_yaml))
  if len(diffs):
    print "Diffs between '%s' and '%s':" % (orig, last)
    for d in diffs:
      print "  " + d

def check_dir(orig, last):
  for filename in os.listdir(orig):
    check_path(os.path.join(orig, filename), os.path.join(last, filename))

def check_path(orig, last):
  if os.path.isdir(orig):
    check_dir(orig, last)
  else:
    check_file(orig, last)

if __name__ == "__main__":
  parser =  optparse.OptionParser("""usage: %prog [options] <dir1> <dir2>

Compare yaml files in <dir1> to yaml files in <dir2> and print the differences.
This is useful to ensure flags are consistent between environments.  There is
a hard coded whitelist of flags which are allowed to differ.""")
  parser.add_option("--noversions",
    dest="versions", default=True, action="store_false",
    help="don't expect version labels")
  (options, args) = parser.parse_args()
  if len(args) != 2:
    parser.print_help()
    sys.exit(1)

  check_path(args[0], args[1])

  if failed:
    sys.exit(2)

