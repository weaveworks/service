package job

import (
	"context"

	log "github.com/sirupsen/logrus"

	"github.com/weaveworks/common/instrument"
	"github.com/weaveworks/common/logging"
	"github.com/weaveworks/service/billing-api/db"
	"github.com/weaveworks/service/common/zuora"
)

// InvoiceUpload sends invoices to Zuora once usage has been processed.
type InvoiceUpload struct {
	db        db.DB
	zuora     zuora.Client
	collector *instrument.JobCollector
}

// NewInvoiceUpload creates an InvoiceUpload instance.
func NewInvoiceUpload(db db.DB, zuora zuora.Client, collector *instrument.JobCollector) *InvoiceUpload {
	return &InvoiceUpload{
		db:        db,
		zuora:     zuora,
		collector: collector,
	}
}

// Run starts the job and logs errors.
func (j *InvoiceUpload) Run() {
	if err := j.Do(); err != nil {
		log.Errorf("Error running invoice job %v", err)
	}
}

// Do starts the job and returns an error if it fails.
func (j *InvoiceUpload) Do() error {
	return instrument.CollectedRequest(context.Background(), "InvoiceUpload.Do", j.collector, nil, func(ctx context.Context) error {
		logger := logging.With(ctx)

		postTrialInvoices, err := j.db.GetPostTrialInvoices(ctx)
		if err != nil {
			return err
		}

		// TODO: monitor number of outstanding invoices
		logger.Infof("Post trial invoices %v", len(postTrialInvoices))

		for _, postTrialInvoice := range postTrialInvoices {
			usageImportID := postTrialInvoice.UsageImportID
			usageImportStatus, err := j.zuora.GetUsageImportStatus(ctx, usageImportID)
			if err != nil {
				logger.Errorf("Failed to get usage import status, id %v: %v", usageImportID, err)
				continue
			}

			if usageImportStatus != zuora.Completed {
				logger.Warningf("Usage state is %v instead of Completed, id %v", usageImportStatus, usageImportID)
				continue
			}

			externalID := postTrialInvoice.ExternalID
			paymentID, err := j.zuora.CreateInvoice(ctx, externalID)
			if err == nil {
				logger.Infof("Created invoice for %v, paymentID %v", externalID, paymentID)
				// now delete the row from post_trial_invoices
			} else {
				// Depending on when the Zuora account is created, on the usage generated by the user, and
				// on the current date and billing periods, this usage might not be chargeable yet.
				if j.zuora.NoChargeableUsage(err) {
					logger.Warnf("Failed to create invoice for %v, as there was not any chargeable usage: %v", externalID, err)
					// now delete the row from post_trial_invoices
				} else if j.zuora.ChargeableUsageTooLow(err) {
					logger.Warnf("Failed to create invoice for %v, as chargeable usage is less than $0.50: %v", externalID, err)
					// now delete the row from post_trial_invoices
				} else {
					logger.Errorf("Failed to create invoice for %v: %v", externalID, err)
					// do not delete the invoice
					// TODO: the row should probably be deleted or (better) ignored if it fails too many times and kept for later analysis.
					continue
				}
			}

			err = j.db.DeletePostTrialInvoice(ctx, usageImportID)
			if err != nil {
				logger.Errorf("Failed to delete post trial invoice %v, %v", usageImportID, err)
				continue
			}
		}

		return nil
	})
}
