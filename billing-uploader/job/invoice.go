package job

import (
	"context"

	"github.com/prometheus/client_golang/prometheus"
	log "github.com/sirupsen/logrus"

	"github.com/weaveworks/common/instrument"
	"github.com/weaveworks/common/logging"
	"github.com/weaveworks/common/user"
	"github.com/weaveworks/service/billing-api/db"
	"github.com/weaveworks/service/common/zuora"
	"github.com/weaveworks/service/users"
)

var (
	invoicesToProcess = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "billing",
		Subsystem: "uploader",
		Name:      "invoices_to_process",
		Help:      "The number of invoices waiting to be processed",
	})
	invoicesProcessedTotal = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: "billing",
		Subsystem: "uploader",
		Name:      "invoices_processed_total",
		Help:      "The number of invoices processed",
	})
)

func init() {
	prometheus.MustRegister(invoicesToProcess)
	prometheus.MustRegister(invoicesProcessedTotal)
}

// InvoiceUpload sends invoices to Zuora once usage has been processed.
type InvoiceUpload struct {
	db        db.DB
	users     users.UsersClient
	zuora     zuora.Client
	collector *instrument.JobCollector
}

// NewInvoiceUpload creates an InvoiceUpload instance.
func NewInvoiceUpload(db db.DB, users users.UsersClient, zuora zuora.Client, collector *instrument.JobCollector) *InvoiceUpload {
	return &InvoiceUpload{
		db:        db,
		users:     users,
		zuora:     zuora,
		collector: collector,
	}
}

// Run starts the job and logs errors.
func (j *InvoiceUpload) Run() {
	if err := j.Do(); err != nil {
		log.Errorf("Error running invoice job %v", err)
	}
}

// Do starts the job and returns an error if it fails.
func (j *InvoiceUpload) Do() error {
	return instrument.CollectedRequest(context.Background(), "InvoiceUpload.Do", j.collector, nil, func(ctx context.Context) error {
		logger := user.LogWith(ctx, logging.Global())

		postTrialInvoices, err := j.db.GetPostTrialInvoices(ctx)
		if err != nil {
			return err
		}

		invoicesToProcess.Set(float64(len(postTrialInvoices)))

		for _, postTrialInvoice := range postTrialInvoices {
			usageImportID := zuora.UsageUploadID(postTrialInvoice.UsageImportID)
			usageImportStatusResp, err := j.zuora.GetUsageImportStatus(
				ctx, j.zuora.GetUsageImportStatusURL(usageImportID))

			if err != nil {
				logger.Errorf("Failed to get usage import status, id %v: %v", usageImportID, err)
				continue
			}

			if usageImportStatusResp.ImportStatus != zuora.Completed {
				logger.Warnf("Usage state is %v instead of Completed, id %v", usageImportStatusResp.ImportStatus, usageImportID)
				continue
			}

			externalID := postTrialInvoice.ExternalID
			resp, err := j.users.GetOrganization(ctx, &users.GetOrganizationRequest{
				ID: &users.GetOrganizationRequest_ExternalID{ExternalID: externalID},
			})
			if err != nil {
				logger.Errorf("Failed to get organization for %v: %v", externalID, err)
				continue
			}
			org := resp.Organization
			paymentID, err := j.zuora.CreateInvoice(ctx, org.ZuoraAccountNumber)
			if err == nil {
				logger.Infof("Created invoice for %v, paymentID %v", externalID, paymentID)
				// now delete the row from post_trial_invoices
			} else {
				// Depending on when the Zuora account is created, on the usage generated by the user, and
				// on the current date and billing periods, this usage might not be chargeable yet.
				if j.zuora.NoChargeableUsage(err) {
					logger.Warnf("Failed to create invoice for %v, as there was not any chargeable usage: %v", externalID, err)
					// now delete the row from post_trial_invoices
				} else if j.zuora.ChargeableUsageTooLow(err) {
					logger.Warnf("Failed to create invoice for %v, as chargeable usage is less than $0.50: %v", externalID, err)
					// now delete the row from post_trial_invoices
				} else {
					logger.Errorf("Failed to create invoice for %v: %v", externalID, err)
					// do not delete the invoice
					// TODO: the row should probably be deleted or (better) ignored if it fails too many times and kept for later analysis.
					continue
				}
			}

			err = j.db.DeletePostTrialInvoice(ctx, string(usageImportID))
			if err != nil {
				logger.Errorf("Failed to delete post trial invoice %v, %v", usageImportID, err)
				continue
			}
			invoicesProcessedTotal.Inc()
		}

		return nil
	})
}
