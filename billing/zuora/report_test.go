package zuora

import (
	"io/ioutil"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

var (
	fixedTime = time.Unix(1515151515, 0)
)

func TestAddLine(t *testing.T) {
	r := NewReport(Config{})
	r.AddLineEntry("id", "node-seconds", 10, time.Now().UTC(), time.Now().UTC(), "subID", "chargeID")
	if len(r.entries) == 0 {
		t.Fatal("Line hasn't been added")
	}
}

func TestToCSV(t *testing.T) {
	testID := "id"
	r := NewReport(Config{})
	r.AddLineEntry(testID, "node-seconds", 10, fixedTime, fixedTime, "subID0", "chargeID0")
	r.AddLineEntry(testID, "node-seconds", 11, fixedTime, fixedTime, "subID1", "chargeID1")
	reader, err := r.ToZuoraFormat()
	if err != nil {
		t.Fatal("Error converting to CSV", err)
	}
	b, err := ioutil.ReadAll(reader)
	if err != nil {
		t.Fatal("Error reading in memory csv o_O", err)
	}
	expected := testID + ",node-seconds,10,01/05/2018,01/05/2018,subID0,chargeID0"
	if !strings.Contains(string(b), expected) {
		t.Fatal("ToCSV method produced invalid data:", string(b), expected)
	}
	expected = "\n"
	if !strings.Contains(string(b), expected) {
		t.Fatal("ToCSV method produced invalid data:", string(b), expected)
	}
}

func TestUnitConversionInDescription(t *testing.T) {
	r := NewReport(Config{})
	r.AddLineEntry("test-id", "node-seconds", 2, fixedTime, fixedTime, "subID0", "chargeID0")
	r.AddLineEntry("test-id", "node-seconds", 2*60, fixedTime, fixedTime, "subID0", "chargeID0")
	r.AddLineEntry("test-id", "node-seconds", 2*60*60, fixedTime, fixedTime, "subID0", "chargeID1")
	r.AddLineEntry("test-id", "node-seconds", 2*60*60*24, fixedTime, fixedTime, "subID0", "chargeID1")
	reader, err := r.ToZuoraFormat()
	assert.Nil(t, err)
	csvBytes, err := ioutil.ReadAll(reader)
	assert.Nil(t, err)
	lines := strings.Split(string(csvBytes), "\n")
	assert.Equal(t, 6, len(lines)) // 1 line for the header, 4 for the above entries, 1 empty line at the end.

	line1 := strings.Split(string(lines[1]), ",")
	assert.NotContains(t, line1[len(line1)-1], "Approx. usage: 2 node-seconds.") // No point converting from "node-seconds" to "node-seconds".
	assert.Contains(t, line1[len(line1)-1], "Generated by billing/uploader on ")

	line2 := strings.Split(string(lines[2]), ",")
	assert.Contains(t, line2[len(line2)-1], "Approx. usage: 2 node-minutes.")
	assert.Contains(t, line2[len(line2)-1], "Generated by billing/uploader on ")

	line3 := strings.Split(string(lines[3]), ",")
	assert.Contains(t, line3[len(line3)-1], "Approx. usage: 2 node-hours.")
	assert.Contains(t, line3[len(line3)-1], "Generated by billing/uploader on ")

	line4 := strings.Split(string(lines[4]), ",")
	assert.Contains(t, line4[len(line4)-1], "Approx. usage: 2 node-days.")
	assert.Contains(t, line4[len(line4)-1], "Generated by billing/uploader on ")
}

func TestToCSVEscaping(t *testing.T) {
	// TODO: I'm not even sure zuora allows this
	testID := "id"
	r := NewReport(Config{})
	r.AddLineEntry(testID, "qu,oted", 10, fixedTime, fixedTime, "subID", "chargeID")
	reader, err := r.ToZuoraFormat()
	if err != nil {
		t.Fatal("Error converting to CSV", err)
	}
	b, err := ioutil.ReadAll(reader)
	if err != nil {
		t.Fatal("Error reading in memory csv o_O", err)
	}
	expected := testID + ",\"qu,oted\",10,01/05/2018,01/05/2018,subID,chargeID"
	if !strings.Contains(string(b), expected) {
		t.Fatal("ToCSV method produced invalid data:", string(b), expected)
	}
	expected = "\n"
	if !strings.Contains(string(b), expected) {
		t.Fatal("ToCSV method produced invalid data:", string(b), expected)
	}
}

func TestConcat(t *testing.T) {
	account1 := "id1"
	account2 := "id2"
	r1 := NewReport(Config{})
	r1.AddLineEntry(account1, "node-seconds", 10, fixedTime, fixedTime, "subID0", "chargeID0")

	r2 := NewReport(Config{})
	r2.AddLineEntry(account2, "node-seconds", 11, fixedTime, fixedTime, "subID1", "chargeID1")

	r3 := r1.ConcatEntries(r2)
	if len(r3.entries) != 2 {
		t.Fatal("Entries missing")
	}
}
