#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

function usage {
        echo "usage: $(basename "$0") up [host_ip] / down" 1>&2
        exit 1
}

if [ $# -lt 1 ]
then
        usage
fi


mode="$1"

toolbox="${TOOLBOX_IMAGE:-"weaveworks/kubernetes-anywhere:toolbox-v1.2.4-6c14c77"}"

script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
local_k8s_dir="${script_dir}/local"

APISERVER_LOCAL_PORT="8001"
APISERVER_LOCAL_BIND="${2:-"0.0.0.0"}"

check_docker_for_mac() {
        local -r docker_for_mac_conf_dir="${HOME}/Library/Containers/com.docker.docker/Data/database/com.docker.driver.amd64-linux"
        [ "$(uname)" = "Darwin" ] \
          && [ ! "${DOCKER_HOST+x}" = x ] \
          && [ -d "${docker_for_mac_conf_dir}" ]
}

check_docker_local() {
        [ -S /var/run/docker.sock ] \
          && docker --host="unix:///var/run/docker.sock" info > /dev/null 2>&1
        ## TODO: figure out if sudo is needed
}

check_docker_machine() {
        [ "${DOCKER_MACHINE_NAME+x}" = x ]
}

function stop_containers {
        docker stop "$@" > /dev/null 2>&1 || true
        docker rm -v "$@" > /dev/null 2>&1 || true
}

kubeconfig="${script_dir}/local/kubeconfig"

function call_kubectl {
        kubectl --kubeconfig="${kubeconfig}" "$@"
}

function write_kubeconfig {
        docker run --rm --tty \
          --env=APISERVER_LOCAL_PORT \
          --volumes-from=kube-toolbox-pki \
          "${toolbox}" \
            print-local-config > "${kubeconfig}"

        if check_docker_machine
        then
              local -r ip="$(docker-machine ip "${DOCKER_MACHINE_NAME}")"
              call_kubectl config set-cluster local-cluster \
                --server="http://${ip}:${APISERVER_LOCAL_PORT}"
        fi

        if echo "${APISERVER_LOCAL_BIND}" | egrep -v -q "(0\.0\.0\.0|127\.0\.0\.1)"
        then
              call_kubectl config set-cluster local-cluster \
                --server="http://${APISERVER_LOCAL_BIND}:${APISERVER_LOCAL_PORT}"
        fi
}

function remove_kubeconfig {
        rm -f "${kubeconfig}"
}

function pull_toolbox() {
        [ "$(docker images -q "${toolbox}" | wc -l)" -eq 1 ] \
          || docker pull "${toolbox}"
}

function tear_down {
        local -a kube=($(docker ps -q -f 'name=kube_*'))
        [ "${#kube[@]}" -gt 0 ] && stop_containers "${kube[@]}"
        docker run --rm --tty \
          --volume="/:/rootfs" \
          --volume="/var/run/docker.sock:/docker.sock" \
            "${toolbox}" \
              reset-single-node > /dev/null 2>&1
        remove_kubeconfig
        local -a -r apps=($(docker ps -q -f 'name=k8s_*'))
        [ "${#apps[@]}" -gt 0 ] && stop_containers "${apps[@]}"
        return 0
}

function launch_weave {
        local -r host="${1}"
        shift
        weave status > /dev/null || (weave launch-router && weave launch-proxy "$@")
        ## Currently Weave Net doesn't persist DNS records
        weave expose -h "${host}.weave.local" > /dev/null
}

function check_node_registered {
  ## TODO: also check status
  [ "$(call_kubectl get nodes -o go-template="{{len .items}}")" -gt 0 ] \
    && [ "$(call_kubectl get nodes -o go-template='{{with index .items 0}}{{.metadata.name}}{{end}}' 2> /dev/null || true)" = "$1" ]
}

function check_kubernetes_service {
  call_kubectl get svc kubernetes >/dev/null 2>&1
}

function stand_up {
        for c in weave kubectl
        do
              if ! command -v "${c}" > /dev/null 2>&1
              then
                      echo "${c} not found" >&2
                      exit 1
              fi
        done


        if check_docker_local && check_docker_for_mac && ! check_docker_machine
        then
              local -r node_name="moby"
              launch_weave "${node_name}" # hostname of Docker for Mac VM
              APISERVER_LOCAL_BIND="127.0.0.1"
        elif check_docker_local && ! check_docker_machine
        then
              local -r node_name="$(hostname)"
              launch_weave "${node_name}"
              eval "$(weave env)"
        elif check_docker_machine
        then
              local -r node_name="${DOCKER_MACHINE_NAME}"
              launch_weave "${node_name}" -H 0.0.0.0:12375 -H /var/run/weave-dummy.sock # work around weaveworks/weave#2302
              eval "$(weave env)"
        else
              echo "Must have local Docker, Docker for Mac or \`DOCKER_MACHINE_NAME\` environment variable set to the name of your VM"
              exit 1
        fi

        export APISERVER_LOCAL_BIND APISERVER_LOCAL_PORT

        docker run --rm --tty \
          --volume="/:/rootfs" \
          --volume="/var/run/weave/weave.sock:/docker.sock" \
            "${toolbox}" \
              setup-single-node

        docker run --rm --tty \
          --env=APISERVER_LOCAL_BIND \
          --env=APISERVER_LOCAL_PORT \
          --env=WEAVE_VERSION \
          --volume="/var/run/weave/weave.sock:/docker.sock" \
            "${toolbox}" \
              compose -p kube up -d

        write_kubeconfig

        local -i t1=120
        until check_kubernetes_service
        do
                echo -n "."
                sleep 1
                if ((--t1 == 0))
                then
                    echo "The \`kubernetes\` service if unvailable - something went completely wrong!"
                    exit 1
                fi
        done
        echo

        local -i t2=120
        until check_node_registered "${node_name}"
        do
                echo -n "."
                sleep 1
                if ((--t2 == 0))
                then
                    echo "Node \`${node_name}\` has not registered properly, check \`docker logs kube_kubelet_1\`."
                    exit 1
                fi
        done
        echo

        echo "Creating cluster addons..."
        call_kubectl create -f "https://raw.github.com/kubernetes/kubernetes-anywhere/master/phase2/docker-images/toolbox/resources/addons-v1.2.yaml"
        echo ""
        echo "Kubernetes is running locally."
	kubeconfig_relative=$(python -c "import os.path; print os.path.relpath('${kubeconfig}', '$(pwd)')")
        echo ""
        echo " kubectl --kubeconfig=${kubeconfig_relative} get pods"
        echo ""
        echo "You may now deploy the application components:"
        echo ""
        echo " kubectl create --kubeconfig=${kubeconfig_relative} -f k8s/local"
        echo " kubectl create --kubeconfig=${kubeconfig_relative} -f k8s/local/kube-system"
        echo " kubectl create --kubeconfig=${kubeconfig_relative} -f k8s/local/aws"
        echo " kubectl create --kubeconfig=${kubeconfig_relative} -f k8s/local/monitoring"
        echo " kubectl create --kubeconfig=${kubeconfig_relative} -f k8s/local/default"
}

if check_docker_machine
then
      eval "$(docker-machine env --shell bash "${DOCKER_MACHINE_NAME}")"
fi

case "${mode}" in
up)
        pull_toolbox
        tear_down
        stand_up
        ;;

down)
        tear_down
        ;;

*)
        echo "Unknown command" 1>&2
        usage
        ;;
esac
