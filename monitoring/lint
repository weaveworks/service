#!/usr/bin/env python2.7

from glob import glob
from itertools import chain
import json
import os
import re
import subprocess
import sys


def get_directory(path):
  """Get the directory that 'path' is in."""
  return os.path.dirname(os.path.abspath(path))


def iter_files(paths):
  """Generate a list of paths to the files under 'paths'."""
  for path in paths:
    if os.path.isfile(path):
      yield path
    else:
      for root, _dirs, filenames in os.walk(path):
        for filename in filenames:
          yield os.path.join(root, filename)


def sort_json_file(path):
  """Sort contents of JSON file."""
  return subprocess.check_output('jq -S . "%s"' % path, shell=True)


def lint_is_json_sorted(path):
  """Yield a warning if JSON file is not sorted."""
  sorted_json = sort_json_file(path)
  actual_json = open(path, 'r').read()
  if sorted_json != actual_json:
    yield 'Keys in JSON file %r are not sorted. Sort with jq -S . "%s"' % (path, path)


def lint_prometheus(path):
  """Yield a warning if a Prometheus rules file has problems."""
  try:
    subprocess.check_output(['promtool', 'check-rules', path])
  except subprocess.CalledProcessError as e:
    yield str(e)


def iter_panels(data):
  for row in data.get('rows', []):
    for panel in row.get('panels', []):
      yield panel


def iter_expressions(data):
  for panel in iter_panels(data):
    for target in panel.get('targets', []):
      yield target['expr']


"""Match the definition of a recording rule.

e.g.
    foo:bar:baz = ...
"""
RECORDING_RULE_DEFINITION_RE = re.compile(r'^([A-Za-z0-9:_]+)\s*=')


def iter_recording_rules(stream):
  """Iterate through names of recording rules in 'stream'."""
  # This is a terrible parser.
  # https://github.com/prometheus/prometheus/blob/master/promql/parse.go is
  # the correct way.
  for line in stream:
    match = RECORDING_RULE_DEFINITION_RE.search(line)
    if not match:
      continue
    yield match.group(1)


"""Match the part of a Prometheus expression that refers to recording rule.

Insists that it has a colon in it.

e.g.
    sum(foo:bar:baz) by (qux)
"""
RECORDING_RULE_RE = re.compile(r'([A-Za-z0-9:_]*:[A-Za-z0-9:_]*)')


def lint_recording_rules(path, data, available_rules):
  for expression in iter_expressions(data):
    # XXX: Doesn't match multiple rules in an expression.
    match = RECORDING_RULE_RE.search(expression)
    if not match:
      continue
    rule = match.group(1)
    if rule not in available_rules:
      yield "%s: recording rule %s not found in rules definitions" % (path, rule)


def lint_unique_panel_ids(path, data):
  """Yield warnings if the panel IDs in 'path' are not unique.

  We want unique IDs so we can edit graphs in our Grafana UI.
  """
  panels = {}
  for panel in iter_panels(data):
    panel_id = panel.get('id', None)
    title = panel.get('title', None)
    title_display = title if title else '<no title found>'
    if panel_id is None:
      yield "%s: panel %r has no 'id' field" % (path, title_display)
      continue
    if panel_id in panels:
      yield "%s: panel %r shares id %s with panel %r" % (path, title_display, panel_id, panels[panel_id])
      continue
    panels[panel_id] = title


def lint_monitoring(directory):
  """Lint monitoring files in 'directory' for correctness."""
  rule_names = set()
  for rules_file in glob('%s/prometheus/*.rules' % directory):
    for warning in lint_prometheus(rules_file):
      yield warning
    with open(rules_file, 'r') as stream:
      rule_names |= set(iter_recording_rules(stream))

  for json_file in glob('%s/grafana/*.json' % directory):
    with open(json_file, 'r') as stream:
      data = json.load(stream)
    warnings = chain(
      lint_is_json_sorted(json_file),
      lint_unique_panel_ids(json_file, data),
      lint_recording_rules(json_file, data, rule_names),
    )
    for warning in warnings:
      yield warning


if __name__ == '__main__':
  directory = get_directory(__file__)
  num_warnings = 0
  for warning in lint_monitoring(directory):
    sys.stderr.write(warning)
    sys.stderr.write('\n')
    num_warnings += 1
  sys.exit(2 if num_warnings else 0)
